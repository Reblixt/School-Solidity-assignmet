{"language":"Solidity","sources":{"src/EventCreator.sol":{"content":"// SPDX-License-Identifier: MIT\n\n//     Pragma statements/\n//     Import statements\n//     Interfaces\n//     Libraries\n//     Contracts\n//\n// Inside each contract, library or interface, use the following order:\n//     Type declarations\n//     State variables\n//     Events\n//     Errors\n//     Modifiers\n//     Constructor\n//     External Functions\n//     Public Functions\n//     getter functions\n//     Internal Functions\n//     Receive and fallback function\npragma solidity ^0.8.26;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract EventCreator is ReentrancyGuard {\n    // This is contract for an event with max 65 000 tickets\n    //////////// Type declarations //////////////\n    struct EventDescription {\n        string eventName;\n        string eventDescription;\n        string eventLocation;\n        uint256 ticketPrice;\n        uint16 totalTickets;\n    }\n\n    struct Attendee {\n        address attendeeAddress;\n        uint16 ticketCount;\n    }\n\n    struct EventInfo {\n        EventDescription eventDescription;\n        address owner;\n        uint16 ticketsSold;\n        uint16 minimumTickets;\n        uint16 attendeeCount;\n        uint256 deadline;\n        EventStatus status;\n        Attendee[] attendees;\n    }\n\n    enum EventStatus {\n        OPEN,\n        PAUSED,\n        ENDED\n    }\n\n    //////////// State variables //////////////\n    address public contractOwner;\n    uint256 public eventId;\n    uint256 public eventBalance;\n\n    mapping(uint256 => uint256) private eventBalances;\n    mapping(uint256 => EventInfo) private events;\n    mapping(string => mapping(address => Attendee)) private eventAttendees;\n\n    //////////// Events //////////////\n    event EventCreated(\n        string eventName,\n        string eventDescription,\n        string eventLocation,\n        uint256 ticketPrice,\n        uint16 totalTickets,\n        address eventOwner\n    );\n    event eventStatus(uint256 eventId, EventStatus status);\n    event AttendeeRegistered(\n        string eventName,\n        address attendeeAddress,\n        uint16 ticketCount\n    );\n    event AttendeeRefunded(\n        string eventName,\n        address attendeeAddress,\n        uint16 ticketCount\n    );\n    event EventOwnerWithdraw(uint256 eventId, uint256 balance);\n\n    //////////// Errors //////////////\n    error EventCreator__NotEventOwner();\n    error EventCreator__NotEnoughEthValue();\n    error EventCreator__NotEnoughTicketsAvailable();\n    error EventCreator__NotEnoughTicketsSold();\n    error EventCreator__EventIsNotOpen();\n    error EventCreator__EventHasAlreadyEnded();\n    error EventCreator__EventDoesNotExist();\n    error EventCreator__ChoosedAInvalidOption();\n    error EventCreator__BeforeEventDeadline();\n    error EventCreator__MustBuyAtLeastOneTicket();\n    error EventCreator__HaveInsufficientFunds();\n    error EventCreator__AttendeeOrEventNameDoesNotExist(\n        string eventName,\n        address attendeeAddress\n    );\n    //////////// Modifiers //////////////\n    modifier onlyEventOwner(uint256 id) {\n        if (msg.sender != events[id].owner)\n            revert EventCreator__NotEventOwner();\n        _;\n    }\n\n    constructor() {\n        contractOwner = msg.sender;\n    }\n\n    //////////// External functions //////////////\n    /*\n     *@dev Create an event with the following parameters\n     *@param newEvent - EventDescription struct that contains the event details\n     *@param deadline - The deadline for the event\n     *@param minimumTickets - The minimum number of tickets that must be sold for the event to take place\n     * */\n    function createEvent(\n        EventDescription memory newEvent,\n        uint256 deadline,\n        uint16 minimumTickets\n    ) external {\n        require(\n            newEvent.totalTickets <= 65000,\n            \"Total tickets cannot exceed 65,000\"\n        );\n        require(deadline > block.timestamp, \"Deadline must be in the future\");\n        ++eventId;\n        EventInfo storage eventInfo = events[eventId];\n        eventInfo.eventDescription = newEvent;\n        eventInfo.owner = msg.sender;\n        eventInfo.ticketsSold = 0;\n        eventInfo.deadline = deadline;\n        eventInfo.minimumTickets = minimumTickets;\n        eventInfo.status = EventStatus.OPEN;\n        events[eventId] = eventInfo;\n        emit EventCreated(\n            newEvent.eventName,\n            newEvent.eventDescription,\n            newEvent.eventLocation,\n            newEvent.ticketPrice,\n            newEvent.totalTickets,\n            msg.sender\n        );\n    }\n\n    /**\n     * @dev Buy a ticket form an event\n     * @param id - The id of the event\n     * @param ticketCount - The number of tickets to buy\n     * @notice The function reverts if the event is not open, the deadline has passed, the ticket count is less than or equal to 0, there are not enough tickets available, the sender has insufficient funds, or the value sent is less than the total cost\n     * @notice The function emits an AttendeeRegistered event if the attendee is successfully registered\n     * @notice The function refunds any excess payment to the sender(Payer)\n     *\n     * */\n    function buyTicket(\n        uint256 id,\n        uint16 ticketCount\n    ) external payable nonReentrant {\n        (EventInfo storage eventInfo, uint256 totalCost) = _checkPermissions(\n            ticketCount,\n            id\n        );\n        // Register the attendee\n        Attendee storage attendee = eventAttendees[\n            eventInfo.eventDescription.eventName\n        ][msg.sender];\n        if (attendee.attendeeAddress == address(0)) {\n            attendee.attendeeAddress = msg.sender;\n            attendee.ticketCount = ticketCount;\n            eventInfo.attendees.push(attendee);\n        }\n        ++eventInfo.attendeeCount;\n        eventInfo.ticketsSold += ticketCount;\n        eventBalances[id] += totalCost;\n\n        // Refund any excess payment\n        if (msg.value > totalCost) {\n            payable(msg.sender).transfer(msg.value - totalCost);\n        }\n\n        emit AttendeeRegistered(\n            eventInfo.eventDescription.eventName,\n            msg.sender,\n            ticketCount\n        );\n    }\n\n    /**\n     * @dev Withdraw the balance of an event\n     * @param id - The id of the event\n     * @notice have the onlyEventOwner modifier\n     * @notice The function reverts if the sender is not the owner of the event, the deadline has not passed, or the event has not ended\n     * @notice The function emits an EventOwnerWithdraw event if the owner successfully withdraws the balance\n     * */\n    function withdraw(uint256 id) external nonReentrant onlyEventOwner(id) {\n        EventInfo storage eventInfo = events[id];\n\n        if (block.timestamp <= eventInfo.deadline)\n            revert EventCreator__BeforeEventDeadline();\n\n        uint256 balance = eventBalances[id];\n        eventBalances[id] = 0;\n        eventInfo.status = EventStatus.ENDED;\n        payable(msg.sender).transfer(balance);\n\n        emit EventOwnerWithdraw(id, balance);\n    }\n\n    /**\n     * @dev Withdraw half of the balance of an event\n     * @param id - The id of the event\n     * @notice have the onlyEventOwner modifier\n     * @notice The function reverts if the sender is not the owner of the event, the deadline has not passed, or the event has not ended\n     * @notice The function emits an EventOwnerWithdraw event if the owner successfully withdraws the balance\n     * */\n    function halfTimeWithdraw(\n        uint256 id\n    ) external nonReentrant onlyEventOwner(id) {\n        EventInfo storage eventInfo = events[id];\n\n        uint256 halfTime = eventInfo.deadline - (eventInfo.deadline / 2);\n\n        if (block.timestamp <= halfTime)\n            revert EventCreator__BeforeEventDeadline();\n        if (eventInfo.ticketsSold < eventInfo.minimumTickets)\n            revert EventCreator__NotEnoughTicketsSold();\n\n        uint256 balance = eventBalances[id];\n        eventBalances[id] = 0;\n        payable(msg.sender).transfer(balance);\n\n        emit EventOwnerWithdraw(id, balance);\n    }\n\n    /**\n     * @dev Pause an event\n     * @param id - The id of the event\n     * @notice have the onlyEventOwner modifier\n     * */\n    function pauseEvent(uint256 id) external onlyEventOwner(id) {\n        EventInfo storage eventInfo = events[id];\n        eventInfo.status = EventStatus.PAUSED;\n\n        emit eventStatus(id, eventInfo.status);\n    }\n\n    /**\n     * @dev Resume a paused event\n     * @param id - The id of the event\n     * @notice have the onlyEventOwner modifier\n     * */\n    function resumeEvent(uint256 id) external onlyEventOwner(id) {\n        EventInfo storage eventInfo = events[id];\n        eventInfo.status = EventStatus.OPEN;\n\n        emit eventStatus(id, eventInfo.status);\n    }\n\n    /**\n     * @dev Cancel an event\n     * @param id - The id of the event\n     * @notice have the onlyEventOwner modifier\n     * */\n    function cancelEvent(uint256 id) external onlyEventOwner(id) {\n        EventInfo storage eventInfo = events[id];\n        eventInfo.status = EventStatus.ENDED;\n\n        _refundEveryoneOfEvent(id);\n\n        emit eventStatus(id, eventInfo.status);\n    }\n\n    /////////// Getter functions /////////////\n\n    function getEvent(uint256 id) external view returns (EventInfo memory) {\n        return events[id];\n    }\n\n    function getAttendeeOfAnEventTicketCount(\n        string memory eventName,\n        address addressOfAttendee\n    ) external view returns (uint16) {\n        if (\n            eventAttendees[eventName][addressOfAttendee].attendeeAddress ==\n            address(0)\n        )\n            revert EventCreator__AttendeeOrEventNameDoesNotExist(\n                eventName,\n                addressOfAttendee\n            );\n        return eventAttendees[eventName][addressOfAttendee].ticketCount;\n    }\n\n    function getEventBalance(uint256 id) external view returns (uint256) {\n        return eventBalances[id];\n    }\n\n    /////////////// Internal functions ///////////////\n\n    /**\n     * @dev Refund everyone of an event\n     * @dev internal function\n     * */\n    function _refundEveryoneOfEvent(uint256 id) internal {\n        EventInfo storage eventInfo = events[id];\n        for (uint256 i = 0; i < eventInfo.attendees.length; ++i) {\n            Attendee storage attendee = eventInfo.attendees[i];\n            uint256 ToRefund = attendee.ticketCount *\n                eventInfo.eventDescription.ticketPrice;\n            payable(attendee.attendeeAddress).transfer(ToRefund);\n\n            eventBalances[id] -= ToRefund;\n\n            emit AttendeeRefunded(\n                eventInfo.eventDescription.eventName,\n                attendee.attendeeAddress,\n                attendee.ticketCount\n            );\n        }\n        assert(eventBalances[id] == 0);\n    }\n\n    /**\n     * @dev Check the permissions of the sender, the event, and the ticket count\n     * @dev internal function\n     * */\n    function _checkPermissions(\n        uint256 ticketCount,\n        uint256 id\n    ) internal view returns (EventInfo storage, uint256) {\n        EventInfo storage eventInfo = events[id];\n        if (eventInfo.status != EventStatus.OPEN)\n            revert EventCreator__EventIsNotOpen();\n\n        if (block.timestamp > eventInfo.deadline)\n            revert EventCreator__EventHasAlreadyEnded();\n\n        if (ticketCount <= 0) revert EventCreator__MustBuyAtLeastOneTicket();\n\n        if (\n            eventInfo.ticketsSold + ticketCount >\n            eventInfo.eventDescription.totalTickets\n        ) revert EventCreator__NotEnoughTicketsAvailable();\n        uint256 totalCost = eventInfo.eventDescription.ticketPrice *\n            ticketCount;\n\n        // if (msg.sender.balance < totalCost)\n        //     revert EventCreator__HaveInsufficientFunds();\n\n        if (msg.value < totalCost) revert EventCreator__NotEnoughEthValue();\n        return (eventInfo, totalCost);\n    }\n\n    //////////// Receive and fallback function //////////////\n\n    fallback() external {\n        revert EventCreator__ChoosedAInvalidOption();\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"}},"settings":{"remappings":["@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/"],"optimizer":{"enabled":true,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":false,"libraries":{}}}
